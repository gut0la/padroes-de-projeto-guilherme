===========================================
PADR√ÉO STRATEGY (ESTRAT√âGIA) - AN√ÅLISE COMPLETA
===========================================

üìã DEFINI√á√ÉO:
O padr√£o Strategy define uma fam√≠lia de algoritmos, encapsula cada um deles
e os torna intercambi√°veis. O Strategy permite que o algoritmo varie
independentemente dos clientes que o utilizam.

üéØ PROBLEMA QUE RESOLVE:

‚ùå PROBLEMAS SEM O PADR√ÉO:
- M√©todos gigantes com estruturas condicionais complexas (if/switch)
- Viola√ß√£o do princ√≠pio Aberto/Fechado (modificar c√≥digo para adicionar algoritmos)
- Viola√ß√£o do princ√≠pio da Responsabilidade √önica (uma classe faz muitas coisas)
- C√≥digo duplicado entre diferentes classes
- Dificuldade para testar algoritmos isoladamente
- Impossibilidade de trocar algoritmos em tempo de execu√ß√£o
- Acoplamento forte entre cliente e implementa√ß√µes espec√≠ficas

‚úÖ SOLU√á√ïES COM O PADR√ÉO:
- Elimina condicionais complexas
- Facilita adi√ß√£o de novos algoritmos
- Permite troca din√¢mica de comportamentos
- Promove reutiliza√ß√£o de c√≥digo
- Facilita testes unit√°rios
- Reduz acoplamento
- Segue princ√≠pios SOLID

üèóÔ∏è COMPONENTES DO PADR√ÉO:

1. STRATEGY (Interface/Classe Abstrata):
   - Define interface comum para todos os algoritmos
   - Declara m√©todo(s) que o Context usar√°
   - Exemplo: EstrategiaAtaque, EstrategiaMovimento, EstrategiaDefesa

2. CONCRETE STRATEGY (Estrat√©gias Concretas):
   - Implementa algoritmos espec√≠ficos usando interface Strategy
   - Cada classe encapsula um comportamento diferente
   - Exemplo: AtaqueCorpoACorpo, AtaqueMagico, AtaqueDistancia

3. CONTEXT (Contexto):
   - Mant√©m refer√™ncia para objeto Strategy
   - Delega trabalho para Strategy ao inv√©s de implementar algoritmos
   - Permite configura√ß√£o de qual algoritmo usar
   - Exemplo: Personagem

üîÑ FLUXO DE FUNCIONAMENTO:

1. Cliente cria Context e Strategy desejada
2. Cliente configura Context com Strategy espec√≠fica
3. Context delega execu√ß√£o para Strategy atual
4. Strategy executa algoritmo e retorna resultado
5. Context pode trocar Strategy a qualquer momento

üí° EXEMPLO PR√ÅTICO (Jogo de Labirinto):

SEM STRATEGY (Problem√°tico):
```java
public class Personagem {
    public void atacar(String tipoAtaque, Personagem alvo) {
        if (tipoAtaque.equals("corpo_a_corpo")) {
            // L√≥gica de ataque corpo a corpo
            int dano = calcularDanoCorpoACorpo();
            // ... c√≥digo espec√≠fico ...
        } else if (tipoAtaque.equals("magico")) {
            // L√≥gica de ataque m√°gico
            int dano = calcularDanoMagico();
            // ... c√≥digo espec√≠fico ...
        } else if (tipoAtaque.equals("distancia")) {
            // L√≥gica de ataque √† dist√¢ncia
            int dano = calcularDanoDistancia();
            // ... c√≥digo espec√≠fico ...
        }
        // Adicionar novo tipo = modificar este m√©todo!
    }
}
```

COM STRATEGY (Elegante):
```java
public class Personagem {
    private EstrategiaAtaque estrategiaAtaque;
    
    public void atacar(Personagem alvo) {
        int dano = estrategiaAtaque.executarAtaque(nome, alvo.getNome(), ataque);
        alvo.receberDano(dano);
    }
    
    // Trocar estrat√©gia em tempo de execu√ß√£o
    public void setEstrategiaAtaque(EstrategiaAtaque estrategia) {
        this.estrategiaAtaque = estrategia;
    }
}
```

‚úÖ BENEF√çCIOS:

1. ELIMINA√á√ÉO DE CONDICIONAIS:
   - Remove if/switch complexos
   - C√≥digo mais limpo e leg√≠vel

2. EXTENSIBILIDADE:
   - Adicionar nova estrat√©gia = criar nova classe
   - N√£o modifica c√≥digo existente
   - Segue princ√≠pio Aberto/Fechado

3. REUTILIZA√á√ÉO:
   - Estrat√©gias podem ser usadas por diferentes contextos
   - Reduz duplica√ß√£o de c√≥digo

4. FLEXIBILIDADE:
   - Troca de algoritmos em tempo de execu√ß√£o
   - Configura√ß√£o din√¢mica de comportamentos

5. TESTABILIDADE:
   - Cada estrat√©gia pode ser testada isoladamente
   - Mocks e stubs mais f√°ceis de criar

6. MANUTENIBILIDADE:
   - Mudan√ßas isoladas em cada estrat√©gia
   - Menor risco de quebrar funcionalidades existentes

‚ùå DESVANTAGENS:

1. COMPLEXIDADE INICIAL:
   - Mais classes para casos simples
   - Overhead de design para algoritmos triviais

2. CONHECIMENTO DAS ESTRAT√âGIAS:
   - Cliente precisa conhecer estrat√©gias dispon√≠veis
   - Pode ser resolvido com Factory ou Builder

3. OVERHEAD DE OBJETOS:
   - Mais objetos em mem√≥ria
   - Pode impactar performance em casos extremos

4. COMUNICA√á√ÉO ENTRE STRATEGY E CONTEXT:
   - Pode ser necess√°rio passar muitos par√¢metros
   - Interface pode ficar complexa

üéØ QUANDO USAR:

‚úÖ USE QUANDO:
- Voc√™ tem m√∫ltiplas maneiras de realizar uma tarefa
- Quer evitar condicionais complexas (if/switch gigantes)
- Algoritmos devem ser intercambi√°veis
- Quer isolar detalhes de implementa√ß√£o
- Precisa de flexibilidade para adicionar novos algoritmos
- Diferentes clientes precisam de diferentes algoritmos

‚ùå N√ÉO USE QUANDO:
- Voc√™ tem apenas um algoritmo
- Algoritmos s√£o muito simples
- Performance √© cr√≠tica e overhead √© inaceit√°vel
- Algoritmos nunca mudam

üîó PADR√ïES RELACIONADOS:

1. STATE:
   - Similar ao Strategy, mas foca em mudan√ßa de estado
   - Strategy foca em algoritmos intercambi√°veis

2. TEMPLATE METHOD:
   - Define esqueleto de algoritmo, Strategy define algoritmos completos
   - Template Method usa heran√ßa, Strategy usa composi√ß√£o

3. FACTORY:
   - Pode ser usado para criar estrat√©gias apropriadas
   - Esconde detalhes de cria√ß√£o do cliente

4. COMMAND:
   - Strategy encapsula algoritmos, Command encapsula requisi√ß√µes
   - Ambos promovem desacoplamento

üåü CASOS DE USO REAIS:

1. SISTEMAS DE PAGAMENTO:
   - PayPal, Cart√£oCr√©dito, Boleto, PIX
   - Cada forma de pagamento = uma estrat√©gia

2. ALGORITMOS DE ORDENA√á√ÉO:
   - QuickSort, MergeSort, BubbleSort
   - Escolha baseada no tamanho dos dados

3. COMPRESS√ÉO DE ARQUIVOS:
   - ZIP, RAR, 7Z, GZIP
   - Diferentes algoritmos para diferentes necessidades

4. VALIDA√á√ÉO DE DADOS:
   - Email, CPF, CNPJ, Telefone
   - Cada tipo de dado = uma estrat√©gia de valida√ß√£o

5. INTELIG√äNCIA ARTIFICIAL EM JOGOS:
   - Comportamentos de NPCs: Agressivo, Defensivo, Furtivo
   - Estrat√©gias de combate baseadas na situa√ß√£o

üìä M√âTRICAS DE QUALIDADE:

COM STRATEGY:
- Complexidade Ciclom√°tica: BAIXA (sem condicionais)
- Acoplamento: BAIXO (interfaces bem definidas)
- Coes√£o: ALTA (cada estrat√©gia tem responsabilidade √∫nica)
- Extensibilidade: ALTA (f√°cil adicionar estrat√©gias)
- Testabilidade: ALTA (testes isolados)

SEM STRATEGY:
- Complexidade Ciclom√°tica: ALTA (muitos if/switch)
- Acoplamento: ALTO (depend√™ncias diretas)
- Coes√£o: BAIXA (uma classe faz muitas coisas)
- Extensibilidade: BAIXA (modificar c√≥digo existente)
- Testabilidade: BAIXA (testes complexos)

üéì LI√á√ïES APRENDIDAS:

1. Strategy transforma condicionais em polimorfismo
2. Composi√ß√£o √© mais flex√≠vel que heran√ßa
3. Interfaces bem definidas s√£o cruciais
4. Cada estrat√©gia deve ter responsabilidade √∫nica
5. Cliente deve conhecer estrat√©gias ou usar Factory
6. Performance vs. Flexibilidade √© um trade-off

üîö CONCLUS√ÉO:

O padr√£o Strategy √© uma ferramenta poderosa para eliminar condicionais
complexas e criar c√≥digo extens√≠vel e manuten√≠vel. Embora adicione
complexidade inicial, os benef√≠cios a longo prazo superam os custos,
especialmente em sistemas que precisam de flexibilidade e extensibilidade.

√â particularmente √∫til quando voc√™ se encontra escrevendo m√©todos com
m√∫ltiplos if/switch ou quando precisa de diferentes algoritmos para
diferentes situa√ß√µes. A chave √© identificar quando a flexibilidade
justifica a complexidade adicional.

===========================================
FIM DA AN√ÅLISE DO PADR√ÉO STRATEGY
===========================================