ANÁLISE DO PADRÃO COMMAND
========================

DEFINIÇÃO:
O padrão Command encapsula uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações, enfileirar ou registrar solicitações e suportar operações que podem ser desfeitas.

PROBLEMA QUE RESOLVE:
- Acoplamento forte entre quem solicita uma operação e quem a executa
- Impossibilidade de desfazer operações realizadas
- Dificuldade para implementar filas de operações, logs e macros
- Violação dos princípios SOLID (especialmente Single Responsibility e Open/Closed)
- Falta de flexibilidade para composição e reutilização de operações

COMPONENTES:

1. COMMAND (Interface):
   - Define o contrato comum para todos os comandos
   - Declara método execute() e opcionalmente undo()
   - Exemplo: Command.java

2. CONCRETE COMMAND (Comando Concreto):
   - Implementa a interface Command
   - Encapsula uma ação específica e seus parâmetros
   - Mantém referência ao Receiver
   - Armazena estado necessário para undo
   - Exemplos: ComandoMovimento.java, ComandoAcao.java

3. RECEIVER (Receptor):
   - Objeto que sabe como executar as operações
   - Contém a lógica de negócio real
   - Exemplos: Jogador.java, SistemaJogo.java

4. INVOKER (Invocador):
   - Solicita execução de comandos
   - Não conhece implementação específica
   - Gerencia histórico e funcionalidades avançadas
   - Exemplo: GerenciadorComandos.java

5. CLIENT (Cliente):
   - Cria objetos Command
   - Associa comandos com receivers apropriados
   - Exemplo: JogoLabirintoComCommand.java

BENEFÍCIOS:

VANTAGEM - DESACOPLAMENTO:
   - Separação entre quem solicita e quem executa
   - Interface não precisa conhecer implementação
   - Facilita manutenção e testes

VANTAGEM - UNDO/REDO:
   - Comandos podem armazenar estado para reversão
   - Histórico completo de operações
   - Implementação robusta de desfazer/refazer

VANTAGEM - COMPOSIÇÃO:
   - Comandos podem ser combinados em macros
   - Suporte a comandos compostos
   - Reutilização de comandos simples

VANTAGEM - FILAS E LOGS:
   - Comandos podem ser enfileirados
   - Execução em lote (batch)
   - Auditoria completa de operações

VANTAGEM - EXTENSIBILIDADE:
   - Novos comandos sem modificar código existente
   - Respeita princípio Open/Closed
   - Factories facilitam criação

VANTAGEM - FLEXIBILIDADE:
   - Execução síncrona ou assíncrona
   - Priorização de comandos
   - Timeout e cancelamento

DESVANTAGENS:

DESVANTAGEM - COMPLEXIDADE INICIAL:
   - Mais classes e interfaces
   - Overhead para operações simples
   - Curva de aprendizado

DESVANTAGEM - OVERHEAD DE MEMÓRIA:
   - Cada comando é um objeto
   - Histórico pode consumir memória
   - Estado para undo aumenta uso

DESVANTAGEM - COMPLEXIDADE DE UNDO:
   - Nem todas operações são reversíveis
   - Estado complexo para desfazer
   - Dependências entre comandos

QUANDO USAR:

RECOMENDADO - NECESSÁRIO:
   - Funcionalidade de undo/redo é essencial
   - Operações precisam ser enfileiradas
   - Logging/auditoria de operações
   - Desacoplamento entre UI e lógica
   - Macros e automação
   - Transações com rollback

NÃO RECOMENDADO - DESNECESSÁRIO:
   - Operações muito simples
   - Sem necessidade de undo
   - Performance crítica
   - Aplicações muito pequenas

EXEMPLO PRÁTICO - JOGO DE LABIRINTO:

SEM PADRÃO (Problemático):
```java
class InterfaceUsuario {
    private Jogador jogador;
    private SistemaJogo sistema;
    
    public void processarComando(String cmd) {
        // PROBLEMA: Acoplamento forte
        if (cmd.equals("norte")) {
            jogador.mover(0, -1);
            sistema.proximoTurno();
            // Sem possibilidade de undo
        } else if (cmd.equals("atacar")) {
            jogador.atacar();
            sistema.adicionarPontos(10);
            // Lógica espalhada, difícil manter
        }
        // Violação SRP e OCP
    }
}
```

COM PADRÃO (Solução):
```java
// COMMAND
interface Command {
    boolean executar();
    boolean desfazer();
    boolean podeSerDesfeito();
}

// CONCRETE COMMAND
class ComandoMoverNorte implements Command {
    private Jogador jogador;
    private SistemaJogo sistema;
    private int xAnterior, yAnterior;
    
    public boolean executar() {
        // Salva estado para undo
        xAnterior = jogador.getX();
        yAnterior = jogador.getY();
        
        // Executa operação
        return jogador.mover(0, -1);
    }
    
    public boolean desfazer() {
        // Restaura estado anterior
        return jogador.setPosicao(xAnterior, yAnterior);
    }
}

// INVOKER
class GerenciadorComandos {
    private Stack<Command> historico;
    
    public boolean executarComando(Command cmd) {
        if (cmd.executar()) {
            historico.push(cmd);
            return true;
        }
        return false;
    }
    
    public boolean desfazer() {
        if (!historico.isEmpty()) {
            return historico.pop().desfazer();
        }
        return false;
    }
}

// CLIENT
class JogoLabirinto {
    public void processarEntrada(String entrada) {
        Command comando = CommandFactory.criar(entrada);
        gerenciador.executarComando(comando);
    }
}
```

COMPARAÇÃO:

SEM PADRÃO:
- Acoplamento forte UI-lógica
- Sem undo/redo
- Difícil testar
- Violação SOLID
- Código duplicado
- Sem filas/macros

COM PADRÃO:
- Desacoplamento total
- Undo/redo robusto
- Fácil testar
- Respeita SOLID
- Reutilização
- Filas/macros/logs

CONCLUSÃO:
O padrão Command é essencial quando precisamos de:
- Operações reversíveis
- Desacoplamento entre interface e lógica
- Filas de operações
- Auditoria e logging
- Composição de operações complexas

Apesar da complexidade inicial, os benefícios superam os custos em aplicações que requerem essas funcionalidades. É um dos padrões mais úteis para interfaces de usuário e sistemas que precisam de controle fino sobre operações.