=== ANÁLISE: CHAIN OF RESPONSIBILITY ===

CONCEITO:
O padrão Chain of Responsibility permite passar solicitações ao longo de uma cadeia de handlers.
Cada handler decide se processa a solicitação ou a passa para o próximo handler na cadeia.

=== COMPARAÇÃO: SEM PADRÃO vs COM PADRÃO ===

SEM PADRÃO (SistemaAprovacaoSemChain.java):
PROBLEMA - LÓGICA CENTRALIZADA: Toda lógica de aprovação em um método
PROBLEMA - RIGIDEZ: Difícil adicionar novos níveis de aprovação
PROBLEMA - ACOPLAMENTO: Cliente conhece todos os níveis de aprovação
PROBLEMA - VIOLAÇÃO SRP: Método faz múltiplas responsabilidades
PROBLEMA - MANUTENÇÃO: Mudanças afetam todo o sistema

COM PADRÃO (SistemaAprovacaoComChain.java):
VANTAGEM - DESACOPLAMENTO: Cliente não conhece handlers específicos
VANTAGEM - FLEXIBILIDADE: Fácil reconfigurar a cadeia
VANTAGEM - EXTENSIBILIDADE: Novos handlers sem modificar código existente
VANTAGEM - SINGLE RESPONSIBILITY: Cada handler uma responsabilidade
VANTAGEM - TESTABILIDADE: Handlers podem ser testados isoladamente

=== ESTRUTURA DO PADRÃO ===

1. Handler (Interface):
   - Define interface comum para todos os handlers
   - Declara método para processar solicitações

2. HandlerBase (Classe Abstrata):
   - Implementa lógica comum de encadeamento
   - Define template method para processamento

3. Handlers Concretos:
   - SupervisorHandler: Aprova até R$ 100
   - GerenteHandler: Aprova até R$ 5.000
   - DiretorHandler: Aprova até R$ 50.000

4. Cliente (SistemaAprovacaoComChain):
   - Configura a cadeia de handlers
   - Envia solicitações para o primeiro handler

=== VANTAGENS DO PADRÃO ===

VANTAGEM - DESACOPLAMENTO:
- Cliente não precisa conhecer handlers específicos
- Handlers não conhecem uns aos outros diretamente

VANTAGEM - FLEXIBILIDADE:
- Cadeia pode ser configurada dinamicamente
- Ordem dos handlers pode ser alterada facilmente

VANTAGEM - EXTENSIBILIDADE:
- Novos handlers podem ser adicionados sem modificar código existente
- Princípio Open/Closed respeitado

VANTAGEM - RESPONSABILIDADE ÚNICA:
- Cada handler tem uma única responsabilidade
- Código mais limpo e organizizado

=== DESVANTAGENS DO PADRÃO ===

DESVANTAGEM - COMPLEXIDADE INICIAL:
- Mais classes e interfaces para casos simples
- Overhead de configuração da cadeia

DESVANTAGEM - PERFORMANCE:
- Solicitação pode passar por vários handlers
- Overhead de chamadas de método

DESVANTAGEM - DEBUGGING:
- Mais difícil rastrear o fluxo de execução
- Cadeia pode ser complexa de debugar

=== QUANDO USAR ===

RECOMENDADO - NECESSÁRIO:
- Múltiplos objetos podem processar uma solicitação
- Conjunto de handlers muda dinamicamente
- Ordem de processamento é importante
- Desacoplamento entre remetente e receptor é necessário

NÃO RECOMENDADO - DESNECESSÁRIO:
- Apenas um objeto processa solicitações
- Lógica de processamento é muito simples
- Performance é crítica
- Cadeia de handlers é sempre a mesma

=== EXEMPLO PRÁTICO ===

Sistema de Aprovação de Despesas:
- Supervisor: até R$ 100
- Gerente: até R$ 5.000
- Diretor: até R$ 50.000
- Acima disso: rejeitado

Fluxo:
1. Solicitação chega ao Supervisor
2. Se pode aprovar, aprova
3. Senão, passa para o Gerente
4. Se pode aprovar, aprova
5. Senão, passa para o Diretor
6. Se pode aprovar, aprova
7. Senão, rejeita

=== CONCLUSÃO ===

O padrão Chain of Responsibility é ideal quando você tem uma cadeia de processamento
onde múltiplos objetos podem processar uma solicitação, mas você não sabe qual
objeto processará até o tempo de execução. Ele promove desacoplamento e flexibilidade,
mas adiciona complexidade estrutural ao código.