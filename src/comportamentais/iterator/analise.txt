=== ANÁLISE: ITERATOR ===

CONCEITO:
O padrão Iterator fornece uma maneira de acessar sequencialmente os elementos de uma
coleção sem expor sua representação interna. Ele separa a lógica de iteração da
estrutura de dados.

=== COMPARAÇÃO: SEM PADRÃO vs COM PADRÃO ===

SEM PADRÃO (CatalogoSemIterator.java):
PROBLEMA - EXPOSIÇÃO INTERNA: Cliente conhece estrutura (duas listas paralelas)
PROBLEMA - ACOPLAMENTO FORTE: Mudança na estrutura quebra código cliente
PROBLEMA - ENCAPSULAMENTO QUEBRADO: Getters expõem coleções internas
PROBLEMA - RESPONSABILIDADES MISTURADAS: Catálogo faz iteração e lógica de negócio
PROBLEMA - CÓDIGO DUPLICADO: Lógica de iteração repetida em vários métodos
PROBLEMA - INFLEXIBILIDADE: Difícil implementar diferentes tipos de iteração

COM PADRÃO (CatalogoComIterator.java):
VANTAGEM - ENCAPSULAMENTO: Estrutura interna completamente oculta
VANTAGEM - DESACOPLAMENTO: Cliente não depende da implementação
VANTAGEM - FLEXIBILIDADE: Múltiplos tipos de iteração (normal, reversa)
VANTAGEM - MÚLTIPLAS ITERAÇÕES: Vários iterators simultâneos
VANTAGEM - UNIFORMIDADE: Interface consistente para diferentes coleções
VANTAGEM - SINGLE RESPONSIBILITY: Cada classe tem uma responsabilidade

=== ESTRUTURA DO PADRÃO ===

1. Iterator (Interface):
   - Define interface comum para navegação
   - Métodos: hasNext(), next(), reset()

2. Aggregate (Interface):
   - Define contrato para coleções iteráveis
   - Método: createIterator()

3. Iterators Concretos:
   - ProdutoIterator: Iteração normal
   - ProdutoIteratorReverso: Iteração reversa

4. Aggregate Concreto:
   - CatalogoProdutos: Implementa coleção de produtos
   - Encapsula array interno

5. Cliente:
   - CatalogoComIterator: Usa iterators sem conhecer implementação

=== VANTAGENS DO PADRÃO ===

VANTAGEM - ENCAPSULAMENTO:
- Estrutura interna da coleção fica oculta
- Cliente não precisa saber se é array, lista, árvore, etc.

VANTAGEM - DESACOPLAMENTO:
- Cliente não depende da implementação específica
- Mudanças na estrutura não afetam código cliente

VANTAGEM - FLEXIBILIDADE:
- Diferentes algoritmos de iteração (normal, reversa, filtrada)
- Fácil adicionar novos tipos de iterator

VANTAGEM - MÚLTIPLAS ITERAÇÕES:
- Vários iterators podem operar simultaneamente
- Cada iterator mantém seu próprio estado

VANTAGEM - UNIFORMIDADE:
- Interface consistente para diferentes tipos de coleção
- Código cliente funciona com qualquer implementação

VANTAGEM - SINGLE RESPONSIBILITY:
- Separação entre lógica de iteração e lógica de negócio
- Cada classe tem uma responsabilidade específica

=== DESVANTAGENS DO PADRÃO ===

DESVANTAGEM - COMPLEXIDADE ADICIONAL:
- Mais classes e interfaces para casos simples
- Overhead de criação de objetos iterator

DESVANTAGEM - PERFORMANCE:
- Chamadas de método adicionais
- Criação de objetos iterator

DESVANTAGEM - MEMÓRIA:
- Cada iterator mantém estado próprio
- Múltiplos iterators consomem mais memória

=== QUANDO USAR ===

RECOMENDADO - NECESSÁRIO:
- Coleção com estrutura interna complexa
- Necessidade de diferentes tipos de iteração
- Múltiplas iterações simultâneas
- Desacoplamento entre cliente e implementação
- Estrutura de dados pode mudar no futuro

NÃO RECOMENDADO - DESNECESSÁRIO:
- Coleções muito simples (poucos elementos)
- Apenas um tipo de iteração necessário
- Performance é extremamente crítica
- Uso de coleções padrão da linguagem já suficiente

=== EXEMPLO PRÁTICO ===

Catálogo de Produtos:
- Estrutura interna: Array de produtos
- Iteração normal: Do primeiro ao último
- Iteração reversa: Do último ao primeiro
- Cliente não conhece que é array internamente

Fluxo:
1. Cliente solicita iterator do catálogo
2. Catálogo cria e retorna iterator apropriado
3. Cliente usa hasNext() e next() para navegar
4. Iterator mantém posição atual internamente
5. Cliente pode resetar ou criar novo iterator

=== VARIAÇÕES DO PADRÃO ===

1. Iterator Externo:
   - Cliente controla a iteração (hasNext/next)
   - Implementação mostrada no exemplo

2. Iterator Interno:
   - Coleção controla a iteração
   - Cliente fornece função callback

3. Iterator Robusto:
   - Detecta modificações na coleção durante iteração
   - Lança exceção se coleção for modificada

=== CONCLUSÃO ===

O padrão Iterator é fundamental para desacoplar clientes de estruturas de dados.
Ele fornece uma interface uniforme para navegação, permitindo diferentes algoritmos
de iteração sem expor detalhes internos. É especialmente útil quando a estrutura
interna é complexa ou pode mudar, mas adiciona complexidade para casos simples.